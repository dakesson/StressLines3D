# Autogenerated with SMOP version 
# main.py soli8e.m
from __future__ import division
def soli8e(ex=None,ey=None,ez=None,ep=None,D=None,eq=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 6-[ex,ey,ez,ep,D,eq].count(None)+len(args)

    ir=ep[1]
    ngp=ir * ir * ir
    if ir == 1:
        g1=0.0
        w1=2.0
        gp=matlabarray(cat(g1,g1))
        w=matlabarray(cat(w1,w1))
    else:
        if ir == 2:
            g1=0.57735026919
            w1=1
            gp[:,1]=cat([- 1],[1],[1],[- 1],[- 1],[1],[1],[- 1]) * g1
            w[:,1]=cat([1],[1],[1],[1],[1],[1],[1],[1]) * w1
            gp[:,2]=cat([- 1],[- 1],[1],[1],[- 1],[- 1],[1],[1]) * g1
            w[:,2]=cat([1],[1],[1],[1],[1],[1],[1],[1]) * w1
            gp[:,3]=cat([- 1],[- 1],[- 1],[- 1],[1],[1],[1],[1]) * g1
            w[:,3]=cat([1],[1],[1],[1],[1],[1],[1],[1]) * w1
        else:
            if ir == 3:
                g1=0.774596669241
                g2=0.0
                w1=0.555555555556
                w2=0.888888888889
                I1=cat([- 1],[0],[1],[- 1],[0],[1],[- 1],[0],[1]).T
                I2=cat([0],[- 1],[0],[0],[1],[0],[0],[1],[0]).T
                gp[:,1]=cat(I1,I1,I1).T * g1
                gp[:,1]=cat(I2,I2,I2).T * g2 + gp[:,1]
                I1=abs_(I1)
                I2=abs_(I2)
                w[:,1]=cat(I1,I1,I1).T * w1
                w[:,1]=cat(I2,I2,I2).T * w2 + w[:,1]
                I1=cat([- 1],[- 1],[- 1],[0],[0],[0],[1],[1],[1]).T
                I2=cat([0],[0],[0],[1],[1],[1],[0],[0],[0]).T
                gp[:,2]=cat(I1,I1,I1).T * g1
                gp[:,2]=cat(I2,I2,I2).T * g2 + gp[:,2]
                I1=abs_(I1)
                I2=abs_(I2)
                w[:,2]=cat(I1,I1,I1).T * w1
                w[:,2]=cat(I2,I2,I2).T * w2 + w[:,2]
                I1=cat([- 1],[- 1],[- 1],[- 1],[- 1],[- 1],[- 1],[- 1],[- 1]).T
                I2=cat([0],[0],[0],[0],[0],[0],[0],[0],[0]).T
                I3=abs_(I1)
                gp[:,3]=cat(I1,I2,I3).T * g1
                gp[:,3]=cat(I2,I3,I2).T * g2 + gp[:,3]
                w[:,3]=cat(I3,I2,I3).T * w1
                w[:,3]=cat(I2,I3,I2).T * w2 + w[:,3]
            else:
                disp(char('Used number of integration points not implemented'))
                return Ke,fe
    wp=w[:,1].dot(w[:,2]).dot(w[:,3])
    xsi=gp[:,1]
    eta=gp[:,2]
    zet=gp[:,3]
    r2=ngp * 3
    N[:,1]=(1 - xsi).dot((1 - eta)).dot((1 - zet)) / 8
    N[:,5]=(1 - xsi).dot((1 - eta)).dot((1 + zet)) / 8
    N[:,2]=(1 + xsi).dot((1 - eta)).dot((1 - zet)) / 8
    N[:,6]=(1 + xsi).dot((1 - eta)).dot((1 + zet)) / 8
    N[:,3]=(1 + xsi).dot((1 + eta)).dot((1 - zet)) / 8
    N[:,7]=(1 + xsi).dot((1 + eta)).dot((1 + zet)) / 8
    N[:,4]=(1 - xsi).dot((1 + eta)).dot((1 - zet)) / 8
    N[:,8]=(1 - xsi).dot((1 + eta)).dot((1 + zet)) / 8
    dNr[1:3:r2,1]=- (1 - eta).dot((1 - zet))
    dNr[1:3:r2,2]=(1 - eta).dot((1 - zet))
    dNr[1:3:r2,3]=(1 + eta).dot((1 - zet))
    dNr[1:3:r2,4]=- (1 + eta).dot((1 - zet))
    dNr[1:3:r2,5]=- (1 - eta).dot((1 + zet))
    dNr[1:3:r2,6]=(1 - eta).dot((1 + zet))
    dNr[1:3:r2,7]=(1 + eta).dot((1 + zet))
    dNr[1:3:r2,8]=- (1 + eta).dot((1 + zet))
    dNr[2:3:r2 + 1,1]=- (1 - xsi).dot((1 - zet))
    dNr[2:3:r2 + 1,2]=- (1 + xsi).dot((1 - zet))
    dNr[2:3:r2 + 1,3]=(1 + xsi).dot((1 - zet))
    dNr[2:3:r2 + 1,4]=(1 - xsi).dot((1 - zet))
    dNr[2:3:r2 + 1,5]=- (1 - xsi).dot((1 + zet))
    dNr[2:3:r2 + 1,6]=- (1 + xsi).dot((1 + zet))
    dNr[2:3:r2 + 1,7]=(1 + xsi).dot((1 + zet))
    dNr[2:3:r2 + 1,8]=(1 - xsi).dot((1 + zet))
    dNr[3:3:r2 + 2,1]=- (1 - xsi).dot((1 - eta))
    dNr[3:3:r2 + 2,2]=- (1 + xsi).dot((1 - eta))
    dNr[3:3:r2 + 2,3]=- (1 + xsi).dot((1 + eta))
    dNr[3:3:r2 + 2,4]=- (1 - xsi).dot((1 + eta))
    dNr[3:3:r2 + 2,5]=(1 - xsi).dot((1 - eta))
    dNr[3:3:r2 + 2,6]=(1 + xsi).dot((1 - eta))
    dNr[3:3:r2 + 2,7]=(1 + xsi).dot((1 + eta))
    dNr[3:3:r2 + 2,8]=(1 - xsi).dot((1 + eta))
    dNr=dNr / 8.0
    Ke=zeros(24,24)
    fe=zeros(24,1)
    JT=dNr * cat([ex],[ey],[ez]).T
    for i in arange(1,ngp).reshape(-1):
        indx=matlabarray(cat([3 * i - 2],[3 * i - 1],[3 * i]))
        detJ=det(JT[indx,:])
        if detJ < 10 * eps:
            disp(char('Jacobideterminant equal or less than zero!'))
        JTinv=inv(JT[indx,:])
        dNx=JTinv * dNr[indx,:]
        B[1,1:3:24 - 2]=dNx[1,:]
        B[2,2:3:24 - 1]=dNx[2,:]
        B[3,3:3:24]=dNx[3,:]
        B[4,1:3:24 - 2]=dNx[2,:]
        B[4,2:3:24 - 1]=dNx[1,:]
        B[5,1:3:24 - 2]=dNx[3,:]
        B[5,3:3:24]=dNx[1,:]
        B[6,2:3:24 - 1]=dNx[3,:]
        B[6,3:3:24]=dNx[2,:]
        N2[1,1:3:24 - 2]=N[i,:]
        N2[2,2:3:24 - 1]=N[i,:]
        N2[3,3:3:24]=N[i,:]
        Ke=Ke + B.T * D * B * detJ * wp[i]
        fe=fe + N2.T * eq * detJ * wp[i]
    return Ke,fe
